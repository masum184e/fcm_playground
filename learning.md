# Contents

- [Routing Mechanism](#routing-mechanism)
  - [Downstream: Admin-to-Client Routing](#downstream-admin-to-client-routing)
    - [Routing Strategies](#routing-strategies)
    - [Admin → Single Client](#admin--single-client)
    - [Admin → Multiple Clients](#admin--multiple-clients)
    - [Admin → Clients via Database](#admin--clients-via-database)
  - [Upstream: Client-to-Admin Routing](#upstream-client-to-admin-routing)
    - [API Routing (Cloud Functions)](#a-api-routing-cloud-functions)
    - [Database Trigger Routing](#b-database-trigger-routing)
- [Target Device](#target-device)
  - [Single Device](#single-device)
  - [Topic Messaging](#topic-messaging)
  - [Condition Targeting](#condition-targeting)
  - [Device Groups](#device-groups)
  - [Summary](#summary-of-target-devices)
- [Message Category](#message-category)
  - [Foreground Message](#foreground-message)
  - [Background Message](#background-message)
  - [`onMessage` and `onBackgroundMessage`](#differences-between-onmessage-and-onbackgroundmessage)
  - [Push Notification](#push-notification)
    - [Notification Messages](#notification-messages)
    - [Data Messages](#data-messages)

# Routing Mechanism

## Downstream: Admin-to-Client Routing

To route a message from your server to a specific device, you must use a Registration Token. This is a unique identifier generated by the Firebase SDK on the client device and sent to your server for storage.

### Routing Strategies:

- **Single Device:** Your Admin SDK sends a message using a specific `token`. This is the most precise method.
- **Topic Messaging:** Clients "subscribe" to a topic (e.g., `news` or `updates`). The Admin SDK sends a message to the Topic Name instead of individual tokens. Firebase handles the "fan-out" to millions of devices.
- **Condition Routing:** You can route messages to users who meet logical conditions, such as: `'TopicA' in topics && ('TopicB' in topics || 'TopicC' in topics)`
- **Device Groups:** Used to group multiple devices belonging to a single user (e.g., a user's phone and tablet) so they receive the same notification.

### Admin → Single Client

```
Admin Server → FCM → Specific Client Device
```

**How It Works**

1. Client app registers with Firebase
2. Firebase generates a device token
3. Token is stored in Firestore under the user profile
4. Admin sends message using that token

**Node.js Server**

```ts
const message = {
  token: userDeviceToken,
  notification: {
    title: "Account Alert",
    body: "Your password was changed successfully",
  },
};

admin.messaging().send(message);
```

### Admin → Multiple Clients

```
Admin → FCM Topic → All Subscribed Clients
```

**Node.js Server**

```ts
const message = {
  topic: "news",
  notification: {
    title: "Breaking News",
    body: "New feature released!",
  },
};

admin.messaging().send(message);
```

- All clients subscribed to `"news"` receive the message
- Useful for broadcasts, announcements, promotions

**Flutter Client**

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

Future<void> subscribeToNews() async {
  await FirebaseMessaging.instance.subscribeToTopic('news');
  print('Subscribed to news topic');
}
```

**Java Client**

```java
// Subscribe to Topic
FirebaseMessaging.getInstance()
        .subscribeToTopic("news")
        .addOnCompleteListener(task -> {
            if (task.isSuccessful()) {
                Log.d("FCM", "Subscribed to news topic");
            }
        });

// Receive Message
@Override
public void onMessageReceived(RemoteMessage remoteMessage) {
    if (remoteMessage.getNotification() != null) {
        Log.d("FCM", remoteMessage.getNotification().getBody());
    }
}
```

**Web Client**

```ts
// Client
import { getMessaging, getToken } from "firebase/messaging";

const messaging = getMessaging();

const token = await getToken(messaging, {
  vapidKey: "YOUR_PUBLIC_VAPID_KEY"
});

fetch ("/api/fcm/subscribe",{token, "news"})

// Server
admin.messaging().subscribeToTopic(token, "news");
```

### Admin → Clients via Database

Instead of push notifications, admin writes data to Firestore.

```
Admin → Firestore → Client Listeners
```

**Node.js Server**

```ts
const db = admin.firestore();
db.collection("announcements").add({
  title: "Maintenance",
  message: "App will be down at midnight",
  createdAt: Timestamp.now(),
});
```

**Flutter Client**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

void listenToAnnouncements() {
  FirebaseFirestore.instance
      .collection('announcements')
      .orderBy('createdAt', descending: true)
      .snapshots()
      .listen((snapshot) {
        for (var doc in snapshot.docs) {
          print(doc['title']);
          print(doc['message']);
        }
      });
}
```

**Java Client**

```java
FirebaseFirestore db = FirebaseFirestore.getInstance();

db.collection("announcements")
  .orderBy("createdAt", Query.Direction.DESCENDING)
  .addSnapshotListener((snapshots, error) -> {
      if (error != null) return;

      for (QueryDocumentSnapshot doc : snapshots) {
          String title = doc.getString("title");
          String message = doc.getString("message");
          Log.d("Firestore", title + ": " + message);
      }
  });

```

**Web Client**

```ts
import { collection, onSnapshot, query, orderBy } from "firebase/firestore";
import { db } from "./firebase";

const q = query(collection(db, "announcements"), orderBy("createdAt", "desc"));

onSnapshot(q, (snapshot) => {
  snapshot.forEach((doc) => {
    console.log(doc.data().title);
    console.log(doc.data().message);
  });
});
```

## Upstream: Client-to-Admin Routing

Direct "Client-to-Server" messaging via FCM (XMPP) is being deprecated in favor of modern web patterns. Instead, Firebase recommends two primary routing paths for clients to talk to the "Admin" side:

### A. API Routing (Cloud Functions)

The client makes an HTTPS request to a Firebase Cloud Function. The function then acts as the "Admin" and can perform logic or trigger a downstream FCM message to other users.

### B. Database Trigger Routing

This is a "reactive" routing pattern:

1. Client writes a message to a specific path in Firestore or Realtime Database.
2. Admin (Cloud Function) listens for the `onCreate` event on that database path.
3. Admin processes the data and uses the Admin SDK to send a response or notification back to the appropriate clients.

# Target Device

## Single Device

A single device is targeted using an FCM registration token.
Each app instance gets a unique token, which you send to your server and store.

**Use cases**

- Personal notifications (chat message, order update)
- Device-specific alerts

**How it works**

- Client app retrieves FCM token
- Token is sent to backend
- Backend sends message to that token

**Example**

```ts
import admin from "firebase-admin";

const message = {
  token: "<DEVICE_FCM_TOKEN>",
  notification: {
    title: "Hello!",
    body: "This message is for a single device",
  },
  data: {
    screen: "profile",
  },
};

await admin.messaging().send(message);
```

## Topic Messaging

Topics allow you to broadcast messages to multiple devices that have subscribed to the same topic.

**Use cases**

- News updates
- Promotions
- Feature announcements

**How it works**

- Devices subscribe/unsubscribe to a topic
- Backend sends a message to the topic
- All subscribed devices receive it

**Example**

Android

```java
FirebaseMessaging.getInstance()
        .subscribeToTopic("news")
        .addOnCompleteListener(task -> {
            if (task.isSuccessful()) {
                Log.d("FCM", "Subscribed to news topic");
            } else {
                Log.e("FCM", "Topic subscription failed");
            }
        });
```

Flutter

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

final FirebaseMessaging messaging = FirebaseMessaging.instance;

await messaging.subscribeToTopic('news');

```

Node.js

```ts
const message = {
  topic: "news",
  notification: {
    title: "Breaking News",
    body: "New feature released!",
  },
};

await admin.messaging().send(message);
```

## Condition Targeting

Condition targeting lets you send messages based on logical expressions of topics.

**Use cases**

- Advanced segmentation
- Region + interest targeting
- Feature flag announcements

**How it works**

- Devices subscribe to multiple topics
- Backend sends message with a boolean condition

**Condition Syntax**

- `&&` → AND
- `||` → OR
- `! `→ NOT

**Node.js**

Send to users interested in sports but not cricket:

```ts
const message = {
  condition: "'sports' in topics && !('cricket' in topics)",
  notification: {
    title: "Sports Update",
    body: "Latest football scores!",
  },
};

await admin.messaging().send(message);
```

## Device Groups

**Device Groups** allow sending messages to multiple devices belonging to one user (e.g., phone + tablet).

> ⚠️ Device Groups are legacy and only supported via HTTP legacy API, not recommended for new systems.
> Firebase suggests Topics or user-level logic instead.

**Use cases**

- Sync notifications across a user’s devices

**How it works**

- Backend creates a notification key
- Multiple device tokens are mapped to that key
- Messages are sent to the notification key

## Summary of Target Devices

| Target Type         | Audience Size | Best For              |
| ------------------- | ------------- | --------------------- |
| Single Device       | 1 device      | Personal alerts       |
| Topic Messaging     | Many devices  | Broadcast messages    |
| Device Groups       | User devices  | (Legacy – avoid)      |
| Condition Targeting | Filtered many | Advanced segmentation |

# Message Category

FCM messages are handled differently depending on the app state:

- **Foreground** → App is open and visible
- **Background** → App is running but not visible, or terminated

## Foreground Message

A foreground message is received when the app is open and active.

- FCM does not automatically display notifications in this state
- The app must handle the message manually
- Ideal for showing in-app alerts, banners, or updating UI

**Typical Use Cases**

- Chat messages
- Live updates
- In-app notifications

**Example**

Flutter Foreground Listner

```dart
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print('Foreground message received');

  if (message.notification != null) {
    print('Title: ${message.notification!.title}');
    print('Body: ${message.notification!.body}');
  }

  if (message.data.isNotEmpty) {
    print('Data payload: ${message.data}');
  }
// Show Snackbar, Dialog, or update UI here
});
```

Android Foreground Handling

```java
public class MyFirebaseMessagingService extends FirebaseMessagingService {

    @Override
    public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {
        // Called when app is in foreground
        if (remoteMessage.getNotification() != null) {
            Log.d("FCM", "Title: " + remoteMessage.getNotification().getTitle());
            Log.d("FCM", "Body: " + remoteMessage.getNotification().getBody());
        }

        if (!remoteMessage.getData().isEmpty()) {
            Log.d("FCM", "Data: " + remoteMessage.getData());
        }

        // Manually show notification or update UI
    }
}
```

## Background Message

A background message is received when:

- App is in background, or
- App is terminated (killed)

**Behavior depends on message type:**

- Notification message → Automatically displayed by the OS
- Data-only message → Delivered to background handler

**Typical Use Cases**

- Silent updates
- Background sync
- Scheduled tasks

**Example**

Flutter Foreground Message Handler

```dart
// Must be a top-level function
@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  print('Background message received');
  print('Message ID: ${message.messageId}');
  print('Data: ${message.data}');
}


// Register the handler
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  FirebaseMessaging.onBackgroundMessage(
    firebaseMessagingBackgroundHandler,
  );

  runApp(MyApp());
}

```

Android Background Behavior

```java
@Override
public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {
    // Data-only messages reach here even in background
    if (!remoteMessage.getData().isEmpty()) {
        Log.d("FCM", "Background Data: " + remoteMessage.getData());
    }
}
```

Notification messages will NOT call `onMessageReceived()` in background — the system handles them automatically.

## Differences between `onMessage` and `onBackgroundMessage`

| Feature                 | `onMessage`       | `onBackgroundMessage`        |
| ----------------------- | ----------------- | ---------------------------- |
| App State               | Foreground        | Background / Terminated      |
| Triggered When          | App is open       | App is not visible           |
| Function Type           | Stream listener   | Top-level function           |
| UI Access               | ✅ Yes            | ❌ No                        |
| Notification Auto-shown | ❌ No             | ✅ (notification messages)   |
| Best For                | In-app UI updates | Silent/background processing |

## Push Notification

A push notification is a message sent from a backend server to a client application via Firebase Cloud Messaging (FCM), even when the app is not actively in use.

FCM supports different message types, which determine how and when messages are delivered and handled by the app.

### Message Types

#### Notification Messages

Notification messages are handled automatically by the operating system (Android/iOS/Web).

- Displayed automatically in the system notification tray
- No app-side code required to show the notification
- Best for simple user-visible alerts

**Characteristics**

- Automatically shown when app is in background or terminated
- Delivered to app code only when app is in foreground
- Limited customization unless combined with data

**Typical Use Cases**

- Promotions
- Announcements
- Reminders

**Node.js Admin SDK**

```ts
const message = {
  token: "<DEVICE_FCM_TOKEN>",
  notification: {
    title: "Welcome!",
    body: "Thanks for joining our app",
  },
};

await admin.messaging().send(message);
```

**Flutter Foreground Only**

```dart
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print(message.notification?.title);
  print(message.notification?.body);
});
```

When the app is in the background, Flutter does not receive this callback — the OS displays the notification automatically.

**Android**

```java
public class MyFirebaseMessagingService extends FirebaseMessagingService {

    @Override
    public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {
        // Called ONLY when app is in foreground
        if (remoteMessage.getNotification() != null) {
            Log.d("FCM", "Title: " + remoteMessage.getNotification().getTitle());
            Log.d("FCM", "Body: " + remoteMessage.getNotification().getBody());
        }
    }
}
```

When the app is in background, notification messages do NOT call
`onMessageReceived()` — Android displays them automatically.

#### Data Messages

Data messages carry custom key-value pairs and are always delivered to the app code.

- App fully controls how to handle the message
- Can be processed in foreground or background
- Can be silent (no notification shown)

**Characteristics**

- No automatic UI
- Ideal for background tasks
- Payload size up to 4 KB

**Typical Use Cases**

- Background sync
- Chat message handling
- Navigation logic
- Feature flags

**Node.js Admin SDK**

```ts
const message = {
  token: "<DEVICE_FCM_TOKEN>",
  data: {
    type: "chat",
    senderId: "user_123",
    messageId: "msg_456",
  },
};

await admin.messaging().send(message);
```

**Flutter**

```dart
// Foreground
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print('Data: ${message.data}');
});


// Background
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print('Data: ${message.data}');
});

```

**Android**

```java
public class MyFirebaseMessagingService extends FirebaseMessagingService {

    @Override
    public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {
        // Data messages arrive here in both foreground & background
        if (!remoteMessage.getData().isEmpty()) {
            Log.d("FCM", "Data Payload: " + remoteMessage.getData());

            String type = remoteMessage.getData().get("type");
            String senderId = remoteMessage.getData().get("senderId");
        }
    }
}
```

#### Notification vs Data Messages

| Feature              | Notification Message | Data Message |
| -------------------- | -------------------- | ------------ |
| Auto-displayed by OS | ✅ Yes               | ❌ No        |
| Requires app code    | ❌ Minimal           | ✅ Yes       |
| Works in background  | ✅ Yes               | ✅ Yes       |
| Silent processing    | ❌ No                | ✅ Yes       |
| UI customization     | Limited              | Full control |
